1) 7.23 in text
	Input: N
	Output: Ones: # of 1s in binary representation

	NumberOfOnes(N, Ones)
		if(N==0)
			return 0
		else 
			if (N & 1 > 0)
				NumberOfOnes(N >> 1, ++Ones)


2)7.17 	a. T(N) = T(N/2) + 1 => NT(N) + NT(N/2) + ... + NT(N/2^(k-2)) = NT(N/2) + ... + NT(1) + (k-1)N
              => NT(N) = NT(1) + (k-1)N => T(N) = k => O(1)
		b. T(N) = T(N/2) + N => T(N) + T(N/2) + ... + T(N/2^(k-2)) = T(N/2) + ... + T(1) + (k-1)N
		      => T(N) = T(1) + (k-1)N = 1 + (k-1)N => O(N)
		e. T(N) = 3T(N/2) + N2=> T(N) = 3^(k-1)N^2=>O(N^2)

3)  a. pre  + a /*+ b c d *- e f g | post d c b +* e f - g */
	b. pre -**/-+ e a b --f g h d c i | post c d e b a -+ f g - h - /** i -

Program Algorithm

Input: N = element in the Lucas number sequence.
Output: output = Nth lucas element

   Holder: vector storing lucas elements Holder[i] = ith Lucas number

Algo:
    Initialize Holder
   	Holder[0] = 2
   	Holder[1] = 1
   	output = FindLucas(abs(N), 2)

   	if N < 0 && N % 2 != 0
   		return -output
   	else
   		return output

	Function: FindLucas(int N, int current) return

   		if Holder.size > (N + 1)
   			return Holder[N]
   		int newLucas = Holder[current - 1] + Holder[current - 2]
   		FindLucas(N, current + 1)



